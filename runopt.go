// Wrapper functions which act as an "external program" to import the lpo and
// gpx packages and exercise functions contained in it.

package main

import (
	"fmt"
	"github.com/Beldin123/gpx"
	"github.com/Beldin123/lpo"
	"github.com/pkg/errors"
	"io/ioutil"
	"os"
	"time"
)

// Flags to control display of menus and use of customized environment.
var mainMenuOn bool = true    // Flag for main LPO functions
var secMenuOn  bool = false   // Flag for secondary LPO functions   
var gpxMenuOn  bool = false   // Flag for GPX functions
var custEnvOn  bool = false   // Flag to enable custom paths and names
var pauseAfter  int = 50      // Number of items to print before pausing

// Customized environment used if custEnvOn = true.
// It is intended to reduce the amount of typing for SOME (not all) user input,
// and to build names of internal files related to the "base" name specified.
// If disabled, user must enter complete directory and file names when prompted.

var dSrcDev       string = "D:/Docs/LP/Data/"           // Development source data dir
var dRgrsRead     string = "D:/Docs/LP/Data/Regres"     // Regression data dir for reading
var dRgrsWrite    string = "D:/Docs/LP/Data/netlib2"    // Regression data dir for writing
var fPrefCplexOut string = "cp_"    // Prefix for Cplex out xml files base on source base name  
var fPrefRdcMps   string = "r_"     // Prefix for MPS file storing reduced matrix
var fPrefPsopOut  string = "psop_"  // Prefix for file storing data removed during PSOP
var fExtension    string = ".txt"   // Extension of source data files in development dir.  

// Need to declare gpx variables here to avoid passing them as arguments to the
// wrapper functions as individual wrapper commands are executed.

var gRows   []gpx.InputRow      // gpx input rows for translation functions
var gCols   []gpx.InputCol      // gpx input cols for translation functions
var gElem   []gpx.InputElem     // gpx input elems for translation functions
var gObj    []gpx.InputObjCoef  // Obj. func. coefficients for translation
var sRows   []gpx.SolnRow       // Solution rows provided by gpx
var sCols   []gpx.SolnCol       // Solution columns provided by gpx


//==============================================================================

// printCplexSoln prints the solution generated by cplex and written to xml file.
// Function requires the parsed solution as input. It returns nothing.
func printCplexSoln(cpSoln lpo.CplexSoln) {
	
	fmt.Println("\nSolution from cplex:\n")

	fmt.Println("Version:        ", cpSoln.Version)
	fmt.Println("ProblemName:    ", cpSoln.Header.ProblemName)
	fmt.Println("ObjValue:       ", cpSoln.Header.ObjValue)
	fmt.Println("SolTypeValue:   ", cpSoln.Header.SolTypeValue)
	fmt.Println("SolTypeString:  ", cpSoln.Header.SolTypeString)
	fmt.Println("SolStatusValue: ", cpSoln.Header.SolStatusValue)
	fmt.Println("SolStatusString:", cpSoln.Header.SolStatusString)
	fmt.Println("SolMethodString:", cpSoln.Header.SolMethodString)
	fmt.Println("PrimalFeasible: ", cpSoln.Header.PrimalFeasible)
	fmt.Println("DualFeasuble:   ", cpSoln.Header.DualFeasible)
	fmt.Println("SimplexItns:    ", cpSoln.Header.SimplexItns)
	fmt.Println("BarrierItns:    ", cpSoln.Header.BarrierItns)
	fmt.Println("WriteLevel:     ", cpSoln.Header.WriteLevel)
	fmt.Println("EpRHS:          ", cpSoln.Quality.EpRHS)
	fmt.Println("EpOpt:          ", cpSoln.Quality.EpOpt)
	fmt.Println("MaxPrimalInfeas:", cpSoln.Quality.MaxPrimalInfeas)
	fmt.Println("MaxDualInfeas:  ", cpSoln.Quality.MaxDualInfeas)
	fmt.Println("MaxPrimalResid: ", cpSoln.Quality.MaxPrimalResidual)
	fmt.Println("MaxDualResidual:", cpSoln.Quality.MaxDualResidual)
	fmt.Println("Quality.MaxX:   ", cpSoln.Quality.MaxX)
	fmt.Println("Quality.MaxPi:  ", cpSoln.Quality.MaxPi)
	fmt.Println("Qual.MaxSlack:  ", cpSoln.Quality.MaxSlack)
	fmt.Println("Qual.MaxRedCost:", cpSoln.Quality.MaxRedCost)
	fmt.Println("Quality.Kappa:  ", cpSoln.Quality.Kappa)
	fmt.Println("LinCons:        ", cpSoln.LinCons)
	fmt.Println("Varbs:          ", cpSoln.Varbs)

}

//==============================================================================

// wpSolveAll is a wrapper for solving all problems in a directory specified by
// the user during program execution. Function expects no arguments and returns nothing.
//
// The files in the directory must be valid MPS data files. The function solves
// each file first by having Cplex directly read the file and produce an xml output
// file which is parsed and interpretted (the old way). It then solves each file
// a second time by applying row and/col scaling and matrix reductions as specified
// during program execution, uses C callable routines to solve the problem (new way)
// and prints the results as well as the comparison between new and old ways to stdout.
func wpSolveAll() {

	var dirName                string  // directory containing MPS data files
	var tmpDir                 string  // directory where tmp files are written
	var fileNameMPS            string  // MPS data file being processed
	var fileCplexOut           string  // Cplex solution file
	var fileReducedMps         string  // MPS file to which reduced problem is written
	var filePsopOut            string  // file storing the PSOP output
	var flagChoice             string  // user input for handling configurable parms.
	var scaleRows, scaleCols     bool  // scaling factors to apply
	var runTB, runRowS           bool  // Row reductions to apply
	var runColS, runFixedVars    bool  // col reductions to apply 
	var runCplex                 bool  // flag if Cplex soln NOT desired
	var savePsop                 bool  // flag if matrix reductions need be saved
	var psCtrl             lpo.PsCtrl  // control structure passed to lpo
	var psResult           lpo.PsSoln  // solution structure received from lpo
	var cpSoln          lpo.CplexSoln  // solution from parsed Cplex xml file
	var files           []os.FileInfo  // handle used when processing files
	var origLogLevel              int  // original log level to restore when function done
	var numFiles                  int  // number of files that were processed
	var numRows, numCols, numElem int  // number of rows, cols, and elems in model
	var lostRows, lostCols        int  // number of rows and cols lost in new way
	var resultOrig, resultLPO float64  // obj. Func. value of old and new way
	var resultDif, percentDif float64  // difference between old and new way
	var err                     error  // error returned from called functions


	fmt.Printf("Enter directory containing MPS files: ")
	fmt.Scanln(&dirName)				
	
	fmt.Printf("\nProcessing directory %s\n", dirName)

	files, err = ioutil.ReadDir(dirName)
	if err != nil {
		fmt.Printf("ERROR: Problem reading directory.\n")
		return
	}	

	// Set options flags.
	fmt.Printf("Flags for scale rows, scale cols, write PSOP: ")
	fmt.Scanln(&scaleRows, &scaleCols, &savePsop)
	fmt.Printf("SolveProb flags ('all' | 'none' | <CR> to set): ")
	fmt.Scanln(&flagChoice)
	
	if flagChoice == "all" {
		runTB        = true
		runRowS      = true
		runColS      = true
		runFixedVars = true
		runCplex     = true	
	} else if flagChoice == "none" {
		runTB        = false
		runRowS      = false
		runColS      = false
		runFixedVars = false
		runCplex     = false			
	} else {
		fmt.Printf("Flags for TB, rowSgltn, colSgltn, fixedVars, runCplex: ")
		fmt.Scanln(&runTB, &runRowS, &runColS, &runFixedVars, &runCplex)		
	}

	// Transfer user input to control structure.	
	psCtrl.DelRowNonbinding = runTB
	psCtrl.DelRowSingleton  = runRowS
	psCtrl.DelColSingleton  = runColS
	psCtrl.DelFixedVars     = runFixedVars
	psCtrl.RunCplex         = runCplex
	psCtrl.MaxIter          = 20

	// Change log level so nothing is printed, print the header, initialize loop.
	_ = lpo.GetLogLevel(&origLogLevel)
	_ = lpo.SetLogLevel(0)
	
	startTime := time.Now()
	fmt.Printf("\n%64s %25s %15s %26s\n", "Iter.", "Iter.", "Removed", "Lost")	
	fmt.Printf("%16s %6s %7s %7s  %14s %4s %5s %14s %4s %5s  %17s %15s %2s %2s\n\n", 
		"File", "Rows", "Cols", "Elem", "Orig. Value", "Bar",
		"Splx", "LPO Value", "Bar", "Splx", "Rows  Cols  Elem", "% Difference", "R", "C")	

	numFiles = 0
	_ = lpo.GetTempDirPath(&tmpDir)

	// Process all files in the directory specified, skip over subdirectories.
    for _, f := range files {

		// Ignore directories.
		if f.IsDir() {
			continue	
		}

		
		// Set file names, read MPS file, and solve via Cplex (old way).		
		numFiles++		
        fmt.Printf("%16s", f.Name())
		fileCplexOut   = tmpDir  + "/" + fPrefCplexOut + f.Name()
		fileReducedMps = tmpDir  + "/" + fPrefRdcMps   + f.Name()
		fileNameMPS    = dirName + "/"                 + f.Name()
		
		if savePsop {
			filePsopOut = tmpDir + "/" + fPrefPsopOut  + f.Name()
		} else {
			filePsopOut = ""
		}
		
		if err = lpo.ReadMpsFile(fileNameMPS); err != nil {
			fmt.Println(err)
			continue			
		}	

		if err = lpo.CplexSolveMps(fileNameMPS, fileCplexOut, "", &cpSoln); err != nil {
			fmt.Println(err)
			continue
		}

		// Record what the original problem had, print it, and add other stats.
		resultOrig = cpSoln.Header.ObjValue
		numRows    = len(lpo.Rows)
		numCols    = len(lpo.Cols)
		numElem    = len(lpo.Elems)
		fmt.Printf("%7d %7d %7d %15e %4d %5d", numRows, numCols, numElem, 
			resultOrig, cpSoln.Header.BarrierItns ,cpSoln.Header.SimplexItns)
		
		if ! psCtrl.RunCplex {
			fmt.Printf("      LPO solution not requested\n")
			continue
		}

		// Set the file-related parameters in the control structure.
		psCtrl.FileInMps        = ""
		psCtrl.FileOutCplexSoln = fileCplexOut
		psCtrl.FileOutMpsRdcd   = fileReducedMps
		psCtrl.FileOutPsop      = filePsopOut

		// Scale rows, cols, or both if requested.
		if scaleRows {
			_ = lpo.ScaleRows()
		}

/* TODO: Temporarily removed because it is not working.
		if scaleCols {
			_ = lpo.ScaleCols()
		}						
*/

		// Solve via lpo and Cplex (new way), record if anything was lost
		// calculate difference between new and old way, and print results.			
		err = lpo.SolveProb(psCtrl, &psResult)
			
		lostRows = numRows - len(psResult.ConMap)
		lostCols = numCols - len(psResult.VarMap)
			 
		if err != nil {
			fmt.Println(err)
		} else {
			resultLPO = psResult.ObjVal
			resultDif = resultOrig - resultLPO

			percentDif = resultDif / resultOrig * 100.0

			if err = lpo.CplexParseSoln(fileCplexOut, &cpSoln); err != nil {
			fmt.Println(err)				
			}
			
			fmt.Printf("%15e %4d %5d  %5d %5d %5d %15e %2d %2d\n", psResult.ObjVal,
				cpSoln.Header.BarrierItns, cpSoln.Header.SimplexItns,
				psResult.RowsDel, psResult.ColsDel, psResult.ElemDel, percentDif,
				lostRows, lostCols)			
		} // End if no errors detected
	
    } // End for processing all files in directory

	// Restore original log level and print how long solution took.
	_ = lpo.SetLogLevel(origLogLevel)

	endTime := time.Now()
	fmt.Printf("\nFiles read:  %d\n", numFiles)
	fmt.Printf("Source dir:  %s\n",   dirName)
	fmt.Printf("Temp dir:    %s\n",   tmpDir)
	fmt.Printf("Started at:  %s\n",   startTime.Format("2006-01-02 15:04:05"))
	fmt.Printf("Finished at: %s\n\n", endTime.Format("2006-01-02 15:04:05"))
		
	return		
}

//==============================================================================

// wpReadWrite is a wrapper for testing ReadMpsFile and WriteMpsFile. It
// reads all files in the directory specified by the user during program execution,
// writes the files to a different directory, solves both sets, and compares the
// results. The function receives no arguments and returns no values.
func wpReadWrite () {

	var dirName                 string  // source directory for reading files
	var destDir                 string  // destination directory for writing files
	var tmpDir                  string  // directory for Cplex output files
	var fileNameMPS             string  // name of MPS file being read
	var destFileName            string  // name of MPS file being written
	var fileCplexOut            string  // Cplex xml output file storing result
	var files            []os.FileInfo  // handle for file being processed
	var cpSoln           lpo.CplexSoln  // structure holding model solution
	var origLogLevel               int  // Original log level
	var numFiles                   int  // number of files in directory
	var numRows, numCols, numElem  int  // number of rows, cols, elems in model
	var resultOrig             float64  // obj. Func. value of original model
	var resultDif, percentDif  float64  // difference between two solutions
	var err                      error  // error returned by called functions


	// Get location of source and destination files from user, and check that
	// they are different.
	
	fmt.Printf("Source directory for reading MPS files: ")
	fmt.Scanln(&dirName)
	
	if custEnvOn {
		destDir = dRgrsWrite		
	} else {
		fmt.Printf("Destination directory for writing MPS files: ")
		fmt.Scanln(&destDir)		
	}			

	if dirName == destDir {
		fmt.Printf("ERROR: Source and destination directories are the same.\n")
		return		
	}

	// Check that directory is readable, record original log level, disable
	// logging and print header.
			
	fmt.Printf("\nProcessing directory %s\n", dirName)

	files, err = ioutil.ReadDir(dirName)
	if err != nil {
		fmt.Printf("ERROR: Reading directory failed.\n")
		return
	}	

	_ = lpo.GetLogLevel(&origLogLevel)
	_ = lpo.SetLogLevel(0)

	startTime := time.Now()
	fmt.Printf("\n%64s %25s %15s %19s\n", "Iter.", "Iter.", "Removed", "Lost")	
	fmt.Printf("%16s %6s %7s %7s  %14s %4s %5s %14s %4s %5s  %17s %8s %2s %2s\n\n", 
		"File", "Rows", "Cols", "Elem", "Orig. Value", "Bar",
		"Splx", "LPO Value", "Bar", "Splx", "Rows  Cols  Elem", "% Diff.", "R", "C")	

	// Initialize counters for number of files read, get directory where Cplex
	// files will be stored while being processed, and loop over all files in
	// source directory.
	
	numFiles = 0
	_        = lpo.GetTempDirPath(&tmpDir)

    for _, f := range files {

		if f.IsDir() {
			continue	
		}

		numFiles++		
        fmt.Printf("%16s", f.Name())
		fileCplexOut = tmpDir  + "/" + fPrefCplexOut + f.Name()
		fileNameMPS  = dirName + "/"                 + f.Name()

		// Read original version of file, solve it, and print results.
				
		if err = lpo.ReadMpsFile(fileNameMPS); err != nil {
			fmt.Println(err)
			continue			
		}	
		
		if err = lpo.CplexSolveMps(fileNameMPS, fileCplexOut, "", &cpSoln); err != nil {
			fmt.Println(err)
			continue
		}

		resultOrig = cpSoln.Header.ObjValue
		numRows = len(lpo.Rows)
		numCols = len(lpo.Cols)
		numElem = len(lpo.Elems)
		fmt.Printf("%7d %7d %7d %15.3f %4d %5d", numRows, numCols, 
			numElem, resultOrig, cpSoln.Header.BarrierItns ,cpSoln.Header.SimplexItns)

		// Write the problem to a file in a different directory and solve again.
		// Although the xml files are saved in same tmp dir as for pass 1, they should
		// have a different prefix (cp2_ vs. the default cp_).		
		destFileName = destDir + "/"     + f.Name()
		fileCplexOut = tmpDir  + "/cp2_" + f.Name()

		if err = lpo.WriteMpsFile(destFileName); err != nil {
			fmt.Println(err)
			continue			
		}	

		if err = lpo.CplexSolveMps(destFileName, fileCplexOut, "", &cpSoln); err != nil {
			fmt.Println(err)
			continue
		}

		// Calculate difference between original and file that was read and written.
		resultDif  = resultOrig - cpSoln.Header.ObjValue
		percentDif = resultDif / resultOrig * 100.0

		// Print results. Since we are using same format as wpSolveAll, parameters 
		// associated with matrix reductions are not applicable and are printed as "0".
		fmt.Printf("%15.3f %4d %5d  %5d %5d %5d %8.4f %2d %2d\n", cpSoln.Header.ObjValue,
			cpSoln.Header.BarrierItns, cpSoln.Header.SimplexItns,
			0, 0, 0, percentDif,
			0, 0)			
	
    } // End for all files in directory

	// Restore original log level and print how long solution took.
	_ = lpo.SetLogLevel(origLogLevel)

	endTime := time.Now()
	fmt.Printf("\nFiles read:  %d\n", numFiles)
	fmt.Printf("Started at:  %s\n",   startTime.Format("2006-01-02 15:04:05"))
	fmt.Printf("Finished at: %s\n\n", endTime.Format("2006-01-02 15:04:05"))
		
	return		
}

//==============================================================================

// wpSolveLP is a wrapper for testing lpo.SolveProb. During execution, it prompts
// the user to specify name of MPS file to be read, or null string if internal
// data structures are already populated with the model. If the custom environment
// flag is set to true, only the base file name of the input file (no directory 
// path, no extension) needs to be provided. Otherwise, the full file paths
// for all input and output files must be provided.
//
// The user is then prompted to set flags controlling which reduction operations 
// are to be performed, the model is passed to the SolveProb function, 
// and the solution is printed. Output of the solution is paused after a set
// number of items are printed to avoid the information from scrolling off the screen.
//
// Function accepts no arguments and returns no values.
func wpSolveLP() {

	var fileNameMPS         string  // MPS input file for the model
	var filePsopOut         string  // output file for pre-solve reductions
	var fileCplexOut        string  // output file for Cplex xml solution
	var flagChoice          string  // flag selection read from user
	var userInput           string  // holder for general input from user
	var counter                int  // counter of how many items were printed
	var runTB, runRowS        bool  // flags for row reductions
	var runColS, runFixedVars bool  // flags for column reductions
	var runCplex              bool  // flag controlling if problem is solved
	var psCtrl          lpo.PsCtrl  // control structure for reductions
	var psResult        lpo.PsSoln  // solution received from lpo
	var err                  error  // error received from called functions

	// Initialize file names to be empty string.
	fileNameMPS  = ""
	fileCplexOut = ""
	filePsopOut  = ""
	
	fmt.Printf("Enter MPS input file name: ")
	fmt.Scanln(&fileNameMPS)
	fmt.Printf("SolveProb flags ('all' | 'none' | <CR> to set): ")
	fmt.Scanln(&flagChoice)
		
	if flagChoice == "all" {
		runTB        = true
		runRowS      = true
		runColS      = true
		runFixedVars = true
		runCplex     = true	
	} else if flagChoice == "none" {
		runTB        = false
		runRowS      = false
		runColS      = false
		runFixedVars = false
		runCplex     = false			
	} else {
		fmt.Printf("Flags for TB, rowSgltn, colSgltn, fixedVars, runCplex: ")
		fmt.Scanln(&runTB, &runRowS, &runColS, &runFixedVars, &runCplex)		
	}

	if custEnvOn {
		// If input file was specified, set output file correspondingly.
		// Otherwise input will be from data structures, and output will be default.
		if fileNameMPS != "" {
			// Create base name using input MPS file and tack on the right prefix.
			fileCplexOut = fPrefCplexOut + fileNameMPS
			filePsopOut  = fPrefPsopOut  + fileNameMPS
			// Add the full directory path and extension.
			fileNameMPS  = dSrcDev + fileNameMPS  + fExtension			
			fileCplexOut = dSrcDev + fileCplexOut + fExtension
			filePsopOut  = dSrcDev + filePsopOut  + fExtension
		}
	} else {
		fmt.Printf("Enter Cplex output file name or <CR> for none: ")
		fmt.Scanln(&fileCplexOut)		
		fmt.Printf("Enter PSOP output file name or <CR> for none: ")
		fmt.Scanln(&filePsopOut)		
	}

	psCtrl.DelRowNonbinding  = runTB
	psCtrl.DelRowSingleton   = runRowS
	psCtrl.DelColSingleton   = runColS
	psCtrl.DelFixedVars      = runFixedVars
	psCtrl.RunCplex          = runCplex
	psCtrl.MaxIter           = 10
	psCtrl.FileInMps         = fileNameMPS
	psCtrl.FileOutCplexSoln  = fileCplexOut
	psCtrl.FileOutPsop       = filePsopOut

	startTime := time.Now()					
	err = lpo.SolveProb(psCtrl, &psResult)
	endTime := time.Now()
			
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("\nOBJECTIVE FUNCTION = %f\n\n", psResult.ObjVal)
		fmt.Printf("Presolve removed %d rows, %d cols, and %d elements.\n",
			psResult.RowsDel, psResult.ColsDel, psResult.ElemDel)
		fmt.Printf("Solution has %d constraints and %d variables.\n", 
			len(psResult.ConMap), len(psResult.VarMap))
		fmt.Printf("Started at:  %s\n",   startTime.Format("2006-01-02 15:04:05"))
		fmt.Printf("Finished at: %s\n\n", endTime.Format("2006-01-02 15:04:05"))
				
		fmt.Printf("To display varb and con results enter 'Y': ")
		fmt.Scanln(&userInput)
		if userInput == "y" || userInput == "Y" {
			
			fmt.Printf("Variables are:\n")
			fmt.Printf("  %-10s %-4s     %15s %15s %15s\n", "NAME", "ST", "VALUE", 
				"REDUCED COST", "SCALE FACTOR")
			
			counter = 0
			userInput = ""
			for psVarbName, psVarb := range psResult.VarMap {
				fmt.Printf("  %-10s %-4s     %15e %15e %15e\n", psVarbName, psVarb.Status,
					psVarb.Value, psVarb.ReducedCost, psVarb.ScaleFactor)
					
				counter++
				if counter == 50 {
					counter = 0
					fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
					fmt.Scanln(&userInput)
					if userInput != "" {
						break 
					}
				} // End if pause required
			} // End for varb range
							
			fmt.Printf("\nConstraints are:\n")

			fmt.Printf("  %-10s %-4s %3s %15s %15s %15s %15s\n", "ROW",
				"ST", "EQ", "RHS", "SLACK", "PI", "SCALE FACTOR")
				
			counter = 0
			userInput = ""
			for psConName,psCon := range psResult.ConMap {
				fmt.Printf("  %-10s %-4s %3s %15e %15e %15e %15e\n",
					psConName, psCon.Status, psCon.Type,
					psCon.Rhs, psCon.Slack, psCon.Pi, psCon.ScaleFactor)
				counter++
				if counter == 50 {
					counter = 0
					fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
					fmt.Scanln(&userInput)
					if userInput != "" {
						break 
					}
				} // End if pause required
			} // End for range of cons
		} // End if displaying varb and con results	
	} // End else there was no error
	
}

//==============================================================================

// wpSolveCplex is a wrapper obtaining a solution directly from an MPS data file.
// During execution, the user provides the name of the source MPS file (base name if
// customEnv is true, full path otherwise). The function sets up the Cplex control
// file, instructs Cplex to read the file and solve it using function lpo.SolveCplexMps.
// The solution xml file is parsed using lpo.CplexParseSoln. The value of the
// objective function as well as the names of all files are displayed to the user.
// If needed, the raw xml output file can be checked in an editor, or via other
// functions provided in this module.
// The function accepts no arguments and returns no values.
func wpSolveCplex() {

	var fileName       string  // MPS input file
	var filePresolve   string  // presolve file used by Cplex
	var fileCplexOut   string  // output file generated by Cplex
	var cpSoln  lpo.CplexSoln  // data structure holding the Cplex solution
	var err             error  // error received from called functions

	// Get the name of the source MPS file and generate other file names from the
	// base name, or prompt user for them if custom environment is disabled.
	
	fmt.Printf("\nEnter MPS file to be read by cplex: ")
	fmt.Scanln(&fileName)
	if custEnvOn {
		filePresolve = ""
		fileCplexOut = dSrcDev + fPrefCplexOut + fileName + fExtension
		fileName     = dSrcDev +                 fileName + fExtension
	} else {
		fmt.Printf("Enter cplex output file: ")
		fmt.Scanln(&fileCplexOut)
		fmt.Printf("Enter presolve file: ")
		fmt.Scanln(&filePresolve)
	}

	// Call the functions to solve the problem, parse the solution, and display
	// the results.
	
	err = lpo.CplexSolveMps(fileName, fileCplexOut, filePresolve, &cpSoln)
	if err != nil {
		fmt.Println(err)
		return			
	}
						
	if err = lpo.CplexParseSoln(fileCplexOut, &cpSoln); err != nil {
		fmt.Println(err)						
	} else {
		fmt.Printf("MPS file read:      %s\n", fileName)
		fmt.Printf("Cplex output:       %s\n", fileCplexOut)
		fmt.Printf("Presolve file:      %s\n", filePresolve)
		fmt.Printf("Objective value:    %f\n", cpSoln.Header.ObjValue)						
	}

	return	
}


//==============================================================================

// wpReduceMtrx is a wrapper for lpo.ReduceMatrix. During execution, it prompts
// the user for all relevant parameters needed to populate the control structure
// and calls the ReduceMatrix function. It assumes that other functions are used
// to populate the model and process the results.
// The function accepts no arguments and returns no values.
func wpReduceMtrx() {

	var psCtrl lpo.PsCtrl   // pre-solve control structure
	var flagChoice string   // choice of which options to select
	var runTB        bool   // run TightenBounds
	var runRowS      bool   // remove row singletons
	var runColS      bool   // remove column singletons
	var runFixedVars bool   // remove fixed variables
	var err         error   // error returned from called functions

	// Initialize the variables, which also become the "none" option provided
	// by the user.
	flagChoice   = ""
	runTB        = false
	runRowS      = false
	runColS      = false
	runFixedVars = false

	// Get the options from the user, and change flags as needed.
	fmt.Printf("SolveProb flags ('all' | 'none' | <CR> to set): ")
	fmt.Scanln(&flagChoice)
	
	if flagChoice == "all" {
		runTB        = true
		runRowS      = true
		runColS      = true
		runFixedVars = true
	} else if flagChoice != "none" {
		fmt.Printf("Flags for TB, rowSgltn, colSgltn, fixedVars: ")
		fmt.Scanln(&runTB, &runRowS, &runColS, &runFixedVars)		
	}

	// Populate the control data structure and call ReduceMatrix.	
	psCtrl.DelRowNonbinding = runTB
	psCtrl.DelRowSingleton  = runRowS
	psCtrl.DelColSingleton  = runColS
	psCtrl.DelFixedVars     = runFixedVars
	psCtrl.RunCplex         = false
	psCtrl.MaxIter          = 20
	psCtrl.FileInMps        = ""
	psCtrl.FileOutCplexSoln  = ""

	if err = lpo.ReduceMatrix(psCtrl); err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("\nReduce matrix completed successfully.\n")
	}
	
}

//==============================================================================

// wpPrintCols prints the native lpo.Cols structure. It pauses after printing
// the number of items configured in a global parameter (default 50).
// The function accepts no arguments and returns no values.
func wpPrintCols() {
	var counter      int  // counter tracking how many cols were printed
	var userInput string  // user input needed after pause
		
	counter = 0
	fmt.Printf("%d columns are:\n", len(lpo.Cols))

	for i := 0; i < len(lpo.Cols); i++ {
		fmt.Println(i, lpo.Cols[i])
		counter++
		if counter == pauseAfter {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			}
		} // End if pause required
	} // End for all columns

	return	
}

//==============================================================================

// wpPrintRows prints the native lpo.Rows structure. It pauses after printing
// the number of items configured in a global parameter (default 50).
// The function accepts no arguments and returns no values.
func wpPrintRows() {
	var counter       int  // counter tracking number of rows printed
	var userInput  string  // user input needed after pause
	
	fmt.Printf("Problem [%s], obj. index %d\n", lpo.Name, lpo.ObjRow)
	counter = 0
	fmt.Printf("%d rows are:\n", len(lpo.Rows))

	for i := 0; i < len(lpo.Rows); i++ {
		fmt.Println(i, lpo.Rows[i])
		counter++
		if counter == pauseAfter {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			} // End if quitting print statement					
		} // End if pause required
	} // End for all rows

	return		
}

//==============================================================================

// wpPrintElems prints the native lpo.Elems structure. It pauses after printing
// the number of items configured in a global parameter (default 50).
// The function accepts no arguments and returns no values.
func wpPrintElems() {
	var counter       int  // counter tracking number of rows printed
	var userInput  string  // user input needed after pause
		
	counter = 0
	fmt.Printf("%d elements are:\n", len(lpo.Elems))

	for i := 0; i < len(lpo.Elems); i++ {
		fmt.Println(i, lpo.Elems[i])
		counter++
		if counter == 50 {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			}
		} // End if pause required
	} // End for all columns

	return	
}

//==============================================================================

// initGpxSoln initializes the data structure which is later populated by other
// functions tested in the gpx package.
// The function accepts the solution row and column slices as input, but returns
// no values. 
func initGpxSoln(sRows []gpx.SolnRow, sCols []gpx.SolnCol) {

	for i := 0; i < len(sCols); i++ {
		sCols[i].Name    = ""
		sCols[i].RedCost = 0.0
		sCols[i].Value   = 0.0
	}

	for i := 0; i < len(sRows); i++ {
		sRows[i].Name  = ""
		sRows[i].Pi    = 0.0
		sRows[i].Slack = 0.0
	}
	
	sRows = nil
	sCols = nil
}

//==============================================================================

// printOptions displays the options that are available for testing. Package
// global flags control which menus are printed.
// The function accepts no arguments and returns no values.
func printOptions() {

	fmt.Println("\nAvailable Options (0 to EXIT):")
	fmt.Println("")
	fmt.Println(" m - main menu toggle  s - sec menu toggle   g - gpx menu toggle   c - cust env toggle")
	
  if mainMenuOn {
	fmt.Println("")
	fmt.Println(" 1 - read MPS file     2 - write MPS file    3 - solve LP          4 - solveAllFiles")
	fmt.Println(" 5 - reduce matrix     6 - write PSOP file   7 - solve MPS cplex   8 - parse cplex sol")
	fmt.Println(" 9 - print model      10 - print raw rows   11 - print raw cols   12 - print raw elems")
	fmt.Println("13 - scale rows       14 -                  15 - print row i      16 - print col j")
  }

  if secMenuOn {
	fmt.Println("")
	fmt.Println("41 - del row          42 - del col          43 - print stats      44 - print RHS")
	fmt.Println("45 - get tempDir path 46 - set tempDir path 47 - get log level    48 - set log level")
	fmt.Println("49 - read/write MPS   50 - tighten bounds")
  }
	
  if gpxMenuOn {
	fmt.Println("")
	fmt.Println("81 - lpo to gpx       82 - init cplex       83 - create problem   84 - chg. prob. name")
	fmt.Println("85 - optimize         86 - get LP soln      87 - get MIP soln     88 - close cplex")
	fmt.Println("89 - gpx to lpo")
  }
}


//==============================================================================

// runWrapper displays the menu of options available, prompts the user to enter
// one of the options, and executes the command specified. The main wrapper controls
// the main commands, and in turn calls secondary wrappers to execute additional
// commands. The flags which control the display of menu options have no impact on
// the available commands. All commands are available even if the corresponding menu
// item is "hidden". The function accepts no arguments and returns no values.
func runWrapper() {

	var cmdOption     string  // command option
	var fileName      string  // holder for names of files  
	var fileCplexOut  string  // holder for second file name where needed
	var inputNum         int  // holder for number provided by user
	var cpSoln lpo.CplexSoln  // Cplex solution of parsed xml file
	var err            error  // error returned by called functions


	// Print header and options, and enter infinite loop until user quits.

	fmt.Println("\nWRAPPER FOR TESTING LPO AND GPX FUNCTIONS.")
	printOptions()
	
	for {

		// Initialize variables, read command, and execute command.
		
		cmdOption    = ""
		fileName     = ""
		fileCplexOut = ""
		
		fmt.Printf("\nEnter a new option: ")
		fmt.Scanln(&cmdOption)

		switch cmdOption {

		//---------------- Commands for toggles --------------------------------
		case "m":
			if mainMenuOn {
				mainMenuOn = false
				fmt.Println("Main menu commands disabled.")
			} else {
				mainMenuOn = true
				fmt.Println("Main menu commands enabled.")				
			}

		case "s":
			if secMenuOn {
				secMenuOn = false
				fmt.Println("Secondary menu commands disabled.")
			} else {
				secMenuOn = true
				fmt.Println("Secondary menu commands enabled.")				
			}
						
		case "g":
			if gpxMenuOn {
				gpxMenuOn = false
				fmt.Println("GPX menu commands disabled.")
			} else {
				gpxMenuOn = true
				fmt.Println("GPX menu commands enabled.")				
			}

		case "c":
			if custEnvOn {
				fmt.Println("Customized environment disabled.")
				custEnvOn = false
			} else {
				fmt.Println("Customized environment enabled.")
				custEnvOn = true				
			}
		
		case "0":
			fmt.Println("\n===> NORMAL PROGRAM TERMINATION <===\n")
			return

		//------------- Functions exercised by main wrapper --------------------
		case "1":
			// Read MPS file
			fmt.Printf("Enter name of MPS file to be read: ")
			fmt.Scanln(&fileName)
			if custEnvOn {
				fileName = dSrcDev + fileName + fExtension
			}
			fmt.Println("Reading file", fileName)
			if err = lpo.ReadMpsFile(fileName); err != nil {
				fmt.Println(err)
			}

		case "2":
			// Write MPS file
			fmt.Printf("Enter MPS output file name: ")
			fmt.Scanln(&fileName)
			if custEnvOn {
				fileName = dSrcDev + fileName + fExtension
			}
			err = lpo.WriteMpsFile(fileName)
			if err != nil {
				fmt.Println(err)
			}

		case "3":
			// Solve single LP
			wpSolveLP()

		case "4":
			// Solve all files in a directory
			wpSolveAll()

		case "5":
			// Reduce matrix (but don't solve)
			wpReduceMtrx()
			
		case "6":
			// Write removed data file
			fmt.Printf("Enter file where PSOP will be written: ")
			fmt.Scanln(&fileName)
			fmt.Printf("Number of coef per line, <0 for all, 0 for none: ")
			fmt.Scanln(&inputNum)				
							
			if custEnvOn {
				fileName  = dSrcDev + "/" + fPrefPsopOut  + fExtension			
			} 
						
			if err = lpo.WritePsopFile(fileName, inputNum); err != nil {
				fmt.Println(err)
			}

		case "7":
			// Solve cplex problem
			wpSolveCplex()
			
		case "8":
			fmt.Printf("Enter cplex output file: ")
			fmt.Scanln(&fileCplexOut)
			if custEnvOn {
				fileCplexOut = dSrcDev + fPrefCplexOut + fileCplexOut + fExtension
			}
			fmt.Printf("Parsing file [%s]...\n", fileCplexOut)
			if err = lpo.CplexParseSoln(fileCplexOut, &cpSoln); err != nil {
				fmt.Println(err)				
			} else {
				printCplexSoln(cpSoln)				
			}

		case "9":
			if err = lpo.PrintModel(); err != nil {
				fmt.Println(err)
			}
		
		case "10":
			// Print lpo Rows data structure
			wpPrintRows()

		case "11":
			// Print lpo Cols data structure
			wpPrintCols()

		case "12":
			// Print lpo Elems data structure
			wpPrintElems()
			
		case "13":	
			_ = lpo.ScaleRows()		

//		case "14":			
//			_ = lpo.ScaleCols()		

		case "15":
			fmt.Printf("Enter index of row to print: ")
			fmt.Scanln(&inputNum)
			if err = lpo.PrintRow(inputNum); err != nil {
				fmt.Println(err)				
			}

		case "16":
			fmt.Printf("Enter index of column to print: ")
			fmt.Scanln(&inputNum)
			if err = lpo.PrintCol(inputNum); err != nil {
				fmt.Println(err)				
			}
			
			
		default:

			// If the command was not present in this wrapper, check the other ones.
			// Only if the command cannot be satisfied by any of the secondary
			// wrappers treat this as an "error" and display the available commands.
			
			if err = runSecWrapper(cmdOption); err == nil {
				// Found the command in secondary menu, continue
				continue
			}	
						
			if err = runGpxWrapper(cmdOption); err == nil {
				// Found the command in gpx menu, continue
				continue
			}
			
			fmt.Printf("Unsupported command: %s", cmdOption)
			printOptions()
						
		} // end of switch on cmdOption
	} // end for looping over commands

}

//==============================================================================

// runSecWrapper executes less important LPO commands for which the display of
// menu items may be hidden to avoid clutter. It is called from the main wrapper
// and accepts the cmdOption as an argument. If the command cannot be executed
// because it does not match any of the cases covered by this wrapper, it returns
// an error.
func runSecWrapper(cmdOption string) error {
	var userString    string  // holder for strings input by user
	var inputNum         int  // holder for integer input by user
	var outputNum        int  // integer received by a called function
	var stats lpo.Statistics  // statistics structure received by called function
	var err            error  // error received by called function
	
	switch cmdOption {
		
		case "41":
			fmt.Printf("Enter index of row to delete: ")
			fmt.Scanln(&inputNum)
			if err = lpo.DelRow(inputNum); err != nil {
				fmt.Println(err)
			}

		case "42":
			fmt.Printf("Enter index of column to delete: ")
			fmt.Scanln(&inputNum)
			if err = lpo.DelCol(inputNum); err != nil {
				fmt.Println(err)
			}

		case "43":
			// Get statistics and print them.
			if err = lpo.GetStatistics(&stats); err != nil {
				fmt.Println(err)
			} else {
				if err = lpo.PrintStatistics(stats); err != nil {
					fmt.Println(err)					
				}
			}
			
		case "44":
			if err = lpo.PrintRhs(); err != nil {
				fmt.Println(err)
			}

		case "45":
			if err = lpo.GetTempDirPath(&userString); err != nil {
				fmt.Println(err)				
			} else {
				fmt.Printf("Temp dir set to %s.\n", userString)
			}
			
		case "46":
			fmt.Printf("Enter new path for temp directory: ")
			fmt.Scanln(&userString)
			if err = lpo.SetTempDirPath(userString); err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("Temp dir changed to %s.\n", userString)
			}
			
		case "47":
			if err = lpo.GetLogLevel(&inputNum); err != nil {
				fmt.Println(err)				
			} else {
				fmt.Printf("Log level set to %d.\n", inputNum)
			}
			
		case "48":
			fmt.Printf("Enter new log level: ")
			fmt.Scanln(&inputNum)
			if err = lpo.SetLogLevel(inputNum); err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("Log level changed to %d.\n", inputNum)
			}

		case "49":
			// Read and write MPS files, solve, compare results
			wpReadWrite()			
			
		case "50":
			// Tighten bounds
			fmt.Printf("Enter number of TightenBounds iterations: ")
			fmt.Scanln(&inputNum)
			if err = lpo.TightenBounds(inputNum, &outputNum); err != nil {
				fmt.Println(err)								
			}
			fmt.Printf("TightenBounds completed %d of %d iterations\n", inputNum, outputNum)

			
		default:
			return errors.Errorf("Command %s not in secondary menu", cmdOption)
		
	} // End of switch on command option
	
	return nil
}

//==============================================================================

// runGpxWrapper executes commands from the GPX package or commands from the
// LPO package which affect GPX functionality (e.g. translations). 
// The display of menu items may be hidden to avoid clutter, but the command
// options remain available even if the menu item is hidden. 
// The function is called from the main wrapper and accepts the cmdOption as an 
// argument. If the command cannot be executed because it does not match any of 
// the cases covered by this wrapper, it returns an error.
func runGpxWrapper(cmdOption string) error {	
	var userString    string        // holder for strings input by user
	var objVal        float64       // value of the objective function
	var err           error         // error returned by functions called

	// The gpx variables used in this function are package global variables so
	// we don't have to pass them to the higher-level wrapper and back again as
	// individual commands that use them are executed.
	
	switch cmdOption {

		case "81":
			fmt.Printf("Translating LPO to GPX.\n")
			err = lpo.TransToGpx(&gRows, &gCols, &gElem, &gObj)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("LPO to GPX translation completed.\n")
			}

		case "82":
			fmt.Printf("Initializing Cplex environment.\n")
			initGpxSoln(sRows, sCols)
			sRows = nil
			sCols = nil
			
			if err = gpx.CreateProb(lpo.Name); err != nil {
				fmt.Println(err)
				break
			} 
			
			if err = gpx.OutputToScreen(true); err != nil {
				fmt.Println(err)
				break
			}
			fmt.Printf("Cplex initialization completed.\n")


		case "83":
			fmt.Printf("Creating new rows.\n")
			if err = gpx.NewRows(gRows); err != nil {
				fmt.Println(err)
				break
			}

			fmt.Printf("Creating new cols.\n")
			if err = gpx.NewCols(gObj, gCols); err != nil {
				fmt.Println(err)
				break
			}

			fmt.Printf("Creating element list.\n")
			if err = gpx.ChgCoefList(gElem); err != nil {
				fmt.Println(err)
				break				
			}			
			fmt.Printf("Model created.\n")

		case "84":
			fmt.Printf("Enter problem name: ")
			fmt.Scanln(&userString)
			if err = gpx.ChgProbName(userString); err != nil {
				fmt.Println(err)				
			} else {
				fmt.Printf("Problem name set to: %s\n", userString)
			}
			

		case "85":
			fmt.Printf("Solving problem.\n")
			if err = gpx.LpOpt(); err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("Solution completed.\n")
			}

		case "86":
			fmt.Printf("Obtaining LP solution.\n")
			err = gpx.GetSolution(&objVal, &sRows, &sCols)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("\nOBJ. VALUE = %e\n", objVal)
				fmt.Printf("\n")
				for i := 0; i < len(sRows); i++ {
					fmt.Printf("Row %3d - %s, Pi = %15e,  Slack = %15e\n", 
						i, sRows[i].Name, sRows[i].Pi, sRows[i].Slack)
				}
				
				fmt.Printf("\n")
				for i := 0; i < len(sCols); i++ {
					fmt.Printf("Col %3d - %s, Val = %15e,  Reduced cost = %15e\n", 
						i, sCols[i].Name, sCols[i].Value, sCols[i].RedCost)
				}
			} // End else no errors
		
		case "87":
			fmt.Printf("Obtaining MIP solution.")
			err = gpx.GetMipSolution(&objVal, &sRows, &sCols)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("\nOBJ. VALUE = %e\n", objVal)
				fmt.Printf("\n")
				for i := 0; i < len(sRows); i++ {
					fmt.Printf("Row %3d - %s, Pi = %15e,  Slack = %15e\n", 
						i, sRows[i].Name, sRows[i].Pi, sRows[i].Slack)
				}
				
				fmt.Printf("\n")
				for i := 0; i < len(sCols); i++ {
					fmt.Printf("Col %3d - %s, Val = %15e,  Reduced cost = %15e\n", 
						i, sCols[i].Name, sCols[i].Value, sCols[i].RedCost)
				}

			} // End else no errors

		
		case "88":
			fmt.Printf("Cleaning up Cplex environment.\n")
			if err = gpx.CloseCplex(); err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("Cplex environment cleaned up successully.")
			}

		
		case "89":
			fmt.Printf("Enter problem name: ")
			fmt.Scanln(&userString)
			err = lpo.TransFromGpx(userString, "", gRows, gCols, gElem, gObj)
			if err != nil {
				fmt.Println(err)
			} else {
				fmt.Printf("GPX to LPO translation completed.")				
			}
												

		default:
			return errors.Errorf("Command %s not in secondary menu", cmdOption)
		
	} // End switch on command option

	
	return nil	
}


//==============================================================================

// MAIN FUNCTION - simply call the wrapper that does all the work.
func main() {

	runWrapper()
}
